import re
import json
import os
import os.path
import typing
import sys
import argparse
import pathlib
import subprocess

# Search the file extension.log generated by Make to found the path to a file named targets.log, containing information about the build
def get_targets_log_path(target : str):
    try:
        makefile_extension_log_file_handle = open(os.path.join(target, ".vscode", "extension.log"), "r")
    except FileNotFoundError:
        print("File `extension.log` not found in the subfolder `.vscode`. Make sure to indicate this value either in `settings.json` or in the workspace settings (file with `.code-workspace` extension). The two parameters to set are `makefile.extensionLog` and `makefile.extensionOutputFolder`")
        sys.exit(-1)

    makefile_extension_log_file_content = makefile_extension_log_file_handle.readlines()
    target_files_raw = set(list(filter(lambda x : x.find("targets.log") != -1, makefile_extension_log_file_content)))
    if len(target_files_raw) == 0:
        print("Path of file `targets.log` not found in the file `extension.log`. Make sure a dry-run has been executed by the Makefile extension. You can make sure of this by launching from VSCode the command `Makefile: Configure`")
        sys.exit(-2)

    for target_file in target_files_raw:
        candidates = target_file.split(" ")
        for candidate in candidates:
            if candidate.find("targets.log") != -1:
                target_file_path = candidate.replace("'", "").replace('"', '').replace("\n", "")
                break
    return target_file_path

def get_variables(targets_file_content : str):
    variables_raw = list(filter(lambda x : re.match(r'^[a-zA-Z0-9_]+\s*:?=', x) is not None, targets_file_content.splitlines()))
    variables = {}

    for variable in variables_raw:
        components = re.match(r'^(?P<name>[a-zA-Z0-9_]+) *:?= *(?P<value>[^\n\r]+)', variable)
        variables[components.group("name")] = components.group("value")

    # Replace the placeholders
    for name, value in variables.items():
        variables[name] = substitute_variables(value, variables)

    return variables

def get_make_execution_directory(targets_file_content : str):
    make_execution_directory = list(filter(
        lambda line : re.search(r"make(\.exe)?: Entering directory", line) is not None,
        targets_file_content.splitlines()))[0]
    make_execution_directory = re.search(r"# make(\.exe)?: Entering directory '(?P<path>[^']+)'", make_execution_directory).group("path")
    make_execution_directory = re.sub(r"^/([a-zA-Z])", r"\1:", make_execution_directory)
    return make_execution_directory

def get_defines(c_flags_line : str, variables : object):
    defines_unextended = list(map(lambda item: item[1], re.findall(r"(\$\(addprefix )?-D,?([^\s]+)", c_flags_line)))
    defines = []
    for define in defines_unextended:
        for value in substitute_variables(define, variables).split(" "):
            defines.append(value)

    return list(set(defines))

def get_cflag_line(targets_file_content : str, variables : object) -> str:
    c_flags_line = ''
    start_found = False
    for line in targets_file_content.splitlines():
        if re.search(r"^C?CFLAGS? =", line) is not None:
            c_flags_line += re.sub(r"^C?CFLAGS? =", r" ", line)
            start_found = True
        elif start_found == True and re.search(r"^#", line) is not None:
            start_found = False
        elif start_found == True:
            c_flags_line += line

    c_flags_line = substitute_variables(c_flags_line, variables)

    return c_flags_line

def substitute_variables(string_with_variables : str, variables : object):
    string_without_variables = string_with_variables
    substitution_pattern_position = string_with_variables.find("$(")
    while substitution_pattern_position != -1:
        substitution = string_without_variables[
            substitution_pattern_position + 2 : string_without_variables.find(")", substitution_pattern_position)]
        if substitution in variables:
            string_without_variables = re.sub(r"\$\(" + substitution + "\)+", variables[substitution], string_without_variables)
            substitution_pattern_position = string_without_variables.find("$(")
        else:
            substitution_pattern_position = string_without_variables.find("$(", substitution_pattern_position + 1)
    else:
        return string_without_variables

def get_include_paths_from_files(target : str, targets_file_content : str, variables : object, make_execution_directory : str):
    # Get the includes from the targets.log file
    include_paths_unextended = set(list(filter(lambda x : x.find("-I") != -1, re.split(r"\s", targets_file_content))))
    include_paths = []

    for include in include_paths_unextended:
        include = include[2:]
        include_paths.append( substitute_variables(include, variables) )

    # Get the includes from the extensions.log file
    extension_log_file_name = os.path.join(target, ".vscode", "extension.log")
    extension_log_file_handle = open(extension_log_file_name, "r")
    extension_log_file_content = extension_log_file_handle.readlines()
    include_paths_absolute = set(list(filter(lambda line : line.find("Includes:") != -1, extension_log_file_content)))
    for line in include_paths_absolute:
        paths = list(filter(None, line[line.find(":")+1:].strip().split(";")))
        for path in paths:
            include_paths.append(path.strip().strip(";"))

    # Make sure the directories exist
    for index, path in enumerate(include_paths):
        make_execution_directory_to_target = os.path.normpath(
                make_execution_directory[make_execution_directory.find(target) + len(target) + 1:])
        # Relative path
        if re.search(r"^[a-zA-Z]:", path) is None:
            abs_path = os.path.normpath(os.path.join(make_execution_directory, os.path.normpath(path)))
            relative_path = os.path.normpath(os.path.join(make_execution_directory_to_target, os.path.normpath(path)))
        # Absolute path
        else:
            abs_path = path
            abs_path_to_target_directory = os.path.normpath(
                make_execution_directory[:make_execution_directory.find(target) + len(target)])
            # Include path is a sub-folder of the target directory
            if path.find(abs_path_to_target_directory) != -1:
                relative_path = path.replace(abs_path_to_target_directory, "").strip("\\").strip("/")
            # Include path is not a sub-folder of the target directory, so we need to compute how many
            # levels to go up
            else:
                common_path = os.path.commonpath((abs_path, os.path.normpath(make_execution_directory)))
                levels_path_include = len(pathlib.PurePath(common_path).parts)
                levels_path_target = len(pathlib.PurePath(abs_path_to_target_directory).parts)
                relative_path = abs_path.replace(common_path, "").strip("\\").strip("/")
                for i in range(levels_path_target - levels_path_include):
                    relative_path = os.path.join("..", relative_path)

        if os.path.isdir(abs_path) == True:
            include_paths[index] = relative_path
        else:
            include_paths[index] = ""

    return list(filter(None, include_paths))

def get_include_path_from_compiler(c_flag_line : str, variables : object, make_execution_directory : str):
    include_paths = []
    # Fetch the compiler command from the list of variables and make sure to separate the executable name
    # from any argument present for subprocess call
    if "CC" in variables:
        compiler_executable = list(variables["CC"].split(" "))
    elif "C" in variables:
        compiler_executable = list(variables["C"].split(" "))

    if compiler_executable[0].find("/") != -1 or compiler_executable[0].find("\\") != -1:
        compiler_executable[0] = os.path.normpath(os.path.join(make_execution_directory, compiler_executable[0]))

    c_flag_line = re.sub(r"\$\(addprefix -(D|I)[^\s]+\)", "", c_flag_line)
    c_flag_line = substitute_variables(c_flag_line, variables)
    c_flag_line = re.sub(r"-(D|I)[^\s]+", "", c_flag_line)
    c_flag_line = re.sub(r"\s{2,}", " ", c_flag_line)
    c_flag_line = " ".join(list(set(c_flag_line.split(" "))))

    test_file_path = os.path.normpath(os.path.join(make_execution_directory, "test.c"))

    with open(test_file_path, "w+") as test_c_file:
        test_c_file.writelines(["#include <stdio.h>", "int main() { return 0; }"])
        test_c_file.close()
        compiler_command = compiler_executable + list(filter(None, c_flag_line.split(" ")))
        compiler_command.append("-xc") # Specify to compile (x) in C (c)
        compiler_command.append("-v")  # Print (on standard error output) the commands executed to run the stages of compilation
        compiler_command.append(test_file_path)
        subprocess_handle = subprocess.run(compiler_command, capture_output=True, env=os.environ.copy(), shell=True)
        stages_compilation = re.split(r"\r\n", subprocess_handle.stderr.decode())

    os.remove(test_file_path)
    start_list_found = False
    for line in stages_compilation:
        if start_list_found == False and re.search(r"#include (\"|<)...(\"|>) search starts here:", line) is not None:
            start_list_found = True
        if start_list_found == True and re.search(r"^ [a-zA-Z]", line) is not None:
            include_paths.append(os.path.normpath(line.strip()))
        if start_list_found == True and re.search(r"End of search list", line) is not None:
            start_list_found = False

    return include_paths


def update_c_cpp_properties_file(target : str, defines : list, include_paths : list, c_flag_line : str):
    # Retrieve the C version
    c_option_search = re.search(r"-std=(?P<version>c[0-9]+)", c_flag_line)
    cpp_option_search = re.search(r"-std=(?P<version>c\+\+[0-9]+)", c_flag_line)

    # Update the C/C++ properties file
    properties_file_name = os.path.join(target, ".vscode", "c_cpp_properties.json")
    properties_file = open(properties_file_name, "r")
    c_cpp_properties = json.load(properties_file)
    for index, configuration in enumerate(c_cpp_properties['configurations']):
        configuration["defines"] = defines
        configuration["includePath"] = include_paths
        if c_option_search is not None:
            configuration["cStandard"] = c_option_search.group("version")
        elif c_option_search is None and "cStandard" in configuration:
            del configuration["cStandard"]

        if cpp_option_search is not None:
            configuration["cppStandard"] = cpp_option_search.group("version")
        elif cpp_option_search is None and "cppStandard" in configuration:
            del configuration["cppStandard"]

        c_cpp_properties["configurations"][index] = configuration
    json.dump(c_cpp_properties, open(properties_file_name, "w+"), indent=4)


if __name__ == "__main__":
    if sys.version_info.major < 3:
        raise Exception("Python 3.5 or a more recent version is required.")
    if sys.version_info.minor < 5:
        raise Exception("Python 3.5 or a more recent version is required.")

    arguments_parser = argparse.ArgumentParser(description="Use the dry-run output of the Makefile VS Code extension to provide configuration for the project. It will replace the content of the c_cpp_properties.json file, specifically the `includePath`, `defines` and `cStandard` JSON elements")
    arguments_parser.add_argument("--target", choices=("mcu", "dsp"), required=True)
    arguments = arguments_parser.parse_args()

    target_file_path = get_targets_log_path(arguments.target)
    file_handle = open(target_file_path, "r")
    content = file_handle.read()

    make_execution_directory = get_make_execution_directory(content)
    variables = get_variables(content)
    c_flag_line = get_cflag_line(content, variables)
    defines = get_defines(c_flag_line, variables)
    include_paths = get_include_paths_from_files(arguments.target, content, variables, make_execution_directory)
    include_paths = include_paths + get_include_path_from_compiler(c_flag_line, variables, make_execution_directory)

    update_c_cpp_properties_file(arguments.target, defines, include_paths, c_flag_line)
